<!DOCTYPE html>
<html>
<head>
    <title>YNABU Reconcile</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
        body { max-width: 1200px; margin: 0 auto; padding: 20px; }
        header { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 20px; }
        header.config input[type="text"], header.config input[type="password"] { padding: 4px 8px; width: 260px; font-family: monospace; font-size: 13px; }
        .config-field { display: flex; flex-direction: column; font-size: 12px; }
        .config-field label { margin-bottom: 2px; color: #666; }
        .error { color: red; }
        .success { color: green; }
        pre { background: #f7f7f7; padding: 10px; }
        .added { color: green; }
        .synced { color: #555; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f5f5f5; }
        th.sortable { cursor: pointer; user-select: none; }
        th.sortable:hover { background-color: #e5e5e5; }
        th.sortable::after { content: ' ↕'; opacity: 0.3; }
        th.sortable.asc::after { content: ' ↑'; opacity: 1; }
        th.sortable.desc::after { content: ' ↓'; opacity: 1; }
        .amount { text-align: right; }
        .amount.negative { color: red; }
        .amount.positive { color: green; }
        .actions { margin: 20px 0; display: flex; gap: 10px; }
        .copy-feedback { opacity: 0; transition: opacity 0.3s; margin-left: 10px; }
        .copy-feedback.show { opacity: 1; }
        #upload-label {
            display: block;
            width: 100%;
            max-width: 800px;
            margin: 40px auto;
            padding: 60px 20px;
            text-align: center;
            border: 2px dashed #aaa;
            background: #f5f5f5;
            cursor: pointer;
            font-size: 24px;
        }
        #upload-label:hover { background: #eee; }
    </style>
</head>
<body>
    <h1>YNABU</h1>

    <header class="config">
        <div class="config-field">
            <label for="token">Token</label>
            <input id="token" name="token" type="password" placeholder="Personal Access Token" title="Personal Access Token">
        </div>
        <div class="config-field">
            <label for="budget">Budget</label>
            <select id="budget" name="budget_id">
                <option value="">Choose budget</option>
            </select>
        </div>
        <div class="config-field">
            <label for="account">Account</label>
            <select id="account" name="account_id">
                <option value="">Choose account</option>
            </select>
        </div>

    </header>


    <!-- Single file input -->
    <label for="statement" id="upload-label">Choose statement file</label>
    <input id="statement" type="file" name="statement" accept=".txt,.xls,.ofx,.csv" required style="display:none">

    <form id="reconcile-form"
          hx-post="/api/process"
          hx-encoding="multipart/form-data"
          hx-trigger="change from:#statement, change from:#account"
          hx-target="#result"
          hx-include="#token,#budget,#account,#statement">
    </form>

    <div id="result"></div>

    <template id="csv-success-template">
        <div class="result-container">
            <div class="actions">
                <a href="" class="download-link">Download CSV</a>
                <button type="button" id="apply-btn">Apply</button>
            </div>
            <table>
                <thead>
                    <tr>
                        <th class="sortable" data-column="date">Date</th>
                        <th class="sortable" data-column="payee">Payee</th>
                        <th class="sortable" data-column="amount">Amount</th>
                        <th class="sortable" data-column="memo">Memo</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </template>

    <script>
        // Persist credentials in localStorage
        function persist(id) {
            const el = document.getElementById(id);
            el.value = localStorage.getItem(id) || "";
            el.addEventListener('input', () => localStorage.setItem(id, el.value));
        }
        ['token'].forEach(persist);

        // Budget and account selection
        const budgetSelect = document.getElementById('budget');
        const accountSelect = document.getElementById('account');
        
        // Load budgets when token changes
        const tokenInput = document.getElementById('token');
        tokenInput.addEventListener('input', debounce(() => {
            // Clear any existing error messages
            const existingError = document.querySelector('.error-message');
            if (existingError) {
                existingError.remove();
            }
            
            const token = tokenInput.value.trim();
            if (token) {
                loadBudgets(token);
            } else {
                budgetSelect.innerHTML = '<option value="">Choose budget</option>';
                accountSelect.innerHTML = '<option value="">Choose account</option>';
                // Clear saved selections when token is cleared
                localStorage.removeItem('budget');
                localStorage.removeItem('account');
            }
        }, 500));
        
        // Load accounts when budget changes
        budgetSelect.addEventListener('change', () => {
            // Clear any existing error messages
            const existingError = document.querySelector('.error-message');
            if (existingError) {
                existingError.remove();
            }
            
            const token = tokenInput.value;
            const budgetId = budgetSelect.value;
            if (token && budgetId) {
                loadAccounts(token, budgetId);
            } else {
                accountSelect.innerHTML = '<option value="">Choose account</option>';
            }
        });
        
        // Persist budget and account selections to localStorage
        const savedBudget = localStorage.getItem('budget') || "";
        const savedAccount = localStorage.getItem('account') || "";
        
        // Restore budget selection
        budgetSelect.value = savedBudget;
        budgetSelect.addEventListener('change', () => {
            localStorage.setItem('budget', budgetSelect.value);
            if (fileInput.files && fileInput.files.length) {
                // Manually trigger the form request so the diff refreshes
                htmx.trigger(budgetSelect, 'change');
            }
        });
        
        // Restore account selection
        accountSelect.value = savedAccount;
        accountSelect.addEventListener('change', () => {
            localStorage.setItem('account', accountSelect.value);
            if (fileInput.files && fileInput.files.length) {
                // Manually trigger the form request so the diff refreshes
                htmx.trigger(accountSelect, 'change');
            }
        });
        
        // Initialize on page load - load budgets if token exists
        function initializeOnLoad() {
            const token = tokenInput.value.trim();
            if (token) {
                loadBudgets(token);
            }
        }
        
        // Run initialization after a short delay to ensure DOM is ready
        setTimeout(initializeOnLoad, 100);
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function showError(message) {
            // Remove any existing error messages
            const existingError = document.querySelector('.error-message');
            if (existingError) {
                existingError.remove();
            }
            
            // Create error message element
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.style.cssText = 'color: red; background: #ffe6e6; border: 1px solid #ff9999; padding: 10px; margin: 10px 0; border-radius: 4px;';
            errorDiv.textContent = message;
            
            // Insert after the config header
            const configHeader = document.querySelector('.config');
            configHeader.insertAdjacentElement('afterend', errorDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.remove();
                }
            }, 5000);
        }

        function loadBudgets(token) {
            budgetSelect.innerHTML = '<option value="">Loading budgets...</option>';
            budgetSelect.disabled = true;
            
            fetch(`/api/budgets?token=${encodeURIComponent(token)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.status === 'success') {
                        budgetSelect.innerHTML = '<option value="">Choose budget</option>';
                        console.log('Budgets response:', data); // Debug log
                        
                        // Handle different possible response structures
                        let budgets = [];
                        if (Array.isArray(data.budgets)) {
                            budgets = data.budgets;
                        } else if (data.budgets && Array.isArray(data.budgets.budgets)) {
                            budgets = data.budgets.budgets;
                        } else if (data.data && Array.isArray(data.data.budgets)) {
                            budgets = data.data.budgets;
                        }
                        
                        budgets.forEach(budget => {
                            const option = document.createElement('option');
                            option.value = budget.id;
                            option.textContent = budget.name;
                            budgetSelect.appendChild(option);
                        });
                        budgetSelect.disabled = false;
                        
                        // Restore saved budget selection
                        const savedBudget = localStorage.getItem('budget') || "";
                        if (savedBudget) {
                            budgetSelect.value = savedBudget;
                            // Trigger account loading if budget is restored
                            const token = tokenInput.value;
                            if (token && savedBudget) {
                                loadAccounts(token, savedBudget);
                            }
                        }
                    } else {
                        throw new Error(data.error || 'Failed to load budgets');
                    }
                })
                .catch(error => {
                    budgetSelect.innerHTML = '<option value="">Choose budget</option>';
                    budgetSelect.disabled = false;
                    showError(`Error loading budgets: ${error.message}`);
                });
        }
        
        function loadAccounts(token, budgetId) {
            accountSelect.innerHTML = '<option value="">Loading accounts...</option>';
            accountSelect.disabled = true;
            
            fetch(`/api/budgets/${budgetId}?token=${encodeURIComponent(token)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.status === 'success') {
                        accountSelect.innerHTML = '<option value="">Choose account</option>';
                        console.log('Accounts response:', data); // Debug log
                        
                        // Handle different possible response structures
                        let accounts = [];
                        if (Array.isArray(data.accounts)) {
                            accounts = data.accounts;
                        } else if (data.accounts && Array.isArray(data.accounts.accounts)) {
                            accounts = data.accounts.accounts;
                        } else if (data.data && Array.isArray(data.data.accounts)) {
                            accounts = data.data.accounts;
                        }
                        
                        accounts.forEach(account => {
                            const option = document.createElement('option');
                            option.value = account.id;
                            option.textContent = account.name;
                            accountSelect.appendChild(option);
                        });
                        accountSelect.disabled = false;
                        
                        // Restore saved account selection
                        const savedAccount = localStorage.getItem('account') || "";
                        if (savedAccount) {
                            accountSelect.value = savedAccount;
                        }
                    } else {
                        throw new Error(data.error || 'Failed to load accounts');
                    }
                })
                .catch(error => {
                    accountSelect.innerHTML = '<option value="">Choose account</option>';
                    accountSelect.disabled = false;
                    showError(`Error loading accounts: ${error.message}`);
                });
        }



        // Update file label on selection
        const fileInput = document.getElementById('statement');
        const fileLabel = document.getElementById('upload-label');
        fileInput.addEventListener('change', () => {
            if (fileInput.files && fileInput.files.length) {
                fileLabel.textContent = fileInput.files[0].name;
            } else {
                fileLabel.textContent = 'Choose statement file';
            }
        });



                // Handle response to show diff and CSV
        document.body.addEventListener('htmx:afterRequest', function(evt) {
            if (evt.detail.successful && evt.detail.target.id === 'result') {
                // Clear previous results
                evt.detail.target.innerHTML = '';
                try {
                    const response = JSON.parse(evt.detail.xhr.response);
                    if (response.status === 'success') {
                        // Summary line
                        const summary = document.createElement('p');
                        summary.textContent = `Plan: ${response.to_add} transaction(s) will be added, ${response.in_sync} already in sync`;
                        evt.detail.target.appendChild(summary);

                        // Table template
                        const template = document.getElementById('csv-success-template');
                        const clone = template.content.cloneNode(true);
                        const link = clone.querySelector('.download-link');
                        link.href = '/api/files/' + response.file;
                        const tbody = clone.querySelector('tbody');

                        if (response.lines && response.lines.length) {
                            // Build diff table rows (+ added, = synced)
                            response.lines.forEach(l => {
                                const trimmed = l.trim();
                                const prefix = trimmed.charAt(0);
                                const content = trimmed.substring(2); // drop prefix and space
                                const parts = content.split('|').map(p => p.trim());
                                if (parts.length >= 3) {
                                    const row = document.createElement('tr');
                                    row.className = prefix === '+' ? 'added' : 'synced';
                                    row.dataset.date = parts[0];
                                    row.dataset.payee = parts[1];
                                    row.dataset.amount = parts[2].replace(/[^\d.,-]/g, '').replace(',', '.');
                                    row.dataset.memo = parts[3] || '';
                                    row.innerHTML = `
                                        <td>${parts[0]}</td>
                                        <td>${parts[1]}</td>
                                        <td class="amount">${parts[2]}</td>
                                        <td>${parts[3] || ''}</td>
                                    `;
                                    tbody.appendChild(row);
                                }
                            });
                        } else {
                            // Fallback: show CSV rows only
                            response.data.forEach(tx => {
                                const row = document.createElement('tr');
                                row.dataset.date = tx.date;
                                row.dataset.payee = tx.payee;
                                row.dataset.amount = tx.amount;
                                row.dataset.memo = tx.memo;
                                row.innerHTML = `
                                    <td>${tx.date}</td>
                                    <td>${tx.payee}</td>
                                    <td class="amount ${tx.amount < 0 ? 'negative' : ''}" data-raw-amount="${tx.amount}">${new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(tx.amount)}</td>
                                    <td>${tx.memo}</td>
                                `;
                                tbody.appendChild(row);
                            });
                        }

                        // Apply initial sort by date (newest first) before adding event listeners
                        const rows = Array.from(tbody.querySelectorAll('tr'));
                        rows.sort((a, b) => {
                            const valA = a.dataset.date.replace(/\//g, '');
                            const valB = b.dataset.date.replace(/\//g, '');
                            return valB.localeCompare(valA); // desc order
                        });
                        rows.forEach(row => tbody.appendChild(row));

                        // Add sorting functionality
                        const table = clone.querySelector('table');
                        const headers = table.querySelectorAll('th.sortable');
                        let currentSort = { column: 'date', direction: 'desc' };

                        headers.forEach(header => {
                            header.addEventListener('click', () => {
                                const column = header.dataset.column;

                                // Toggle direction if clicking same column, otherwise reset to desc for date, asc for others
                                if (currentSort.column === column) {
                                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                                } else {
                                    currentSort.column = column;
                                    currentSort.direction = column === 'date' ? 'desc' : 'asc';
                                }

                                // Update header classes
                                headers.forEach(h => h.classList.remove('asc', 'desc'));
                                header.classList.add(currentSort.direction);

                                // Sort rows
                                const rows = Array.from(tbody.querySelectorAll('tr'));
                                rows.sort((a, b) => {
                                    let valA = a.dataset[column];
                                    let valB = b.dataset[column];

                                    if (column === 'date') {
                                        // Date is already in yyyy/mm/dd format, just remove slashes for comparison
                                        valA = valA.replace(/\//g, '');
                                        valB = valB.replace(/\//g, '');
                                    } else if (column === 'amount') {
                                        valA = parseFloat(valA);
                                        valB = parseFloat(valB);
                                    }

                                    if (valA < valB) return currentSort.direction === 'asc' ? -1 : 1;
                                    if (valA > valB) return currentSort.direction === 'asc' ? 1 : -1;
                                    return 0;
                                });

                                // Re-append rows in sorted order
                                rows.forEach(row => tbody.appendChild(row));
                            });
                        });

                        // Mark date header with desc indicator
                        const dateHeader = Array.from(headers).find(h => h.dataset.column === 'date');
                        if (dateHeader) {
                            dateHeader.classList.add('desc');
                        }

                                                // wire apply button
                        const applyBtn = clone.querySelector('#apply-btn');
                        applyBtn.addEventListener('click', async () => {
                            const f = fileInput.files[0];
                            const acc = accountSelect.value;
                            const budget = budgetSelect.value;
                            const token = tokenInput.value;
                            if (!f || !acc || !budget || !token) { alert('choose file, budget, account and token'); return; }
                            const fd = new FormData();
                            fd.append('statement', f);
                            fd.append('account_id', acc);
                            fd.append('budget_id', budget);
                            fd.append('token', token);
                            const res = await fetch('/api/apply', { method: 'POST', body: fd });
                            const j = await res.json();
                            alert(j.status === 'applied' ? 'Applied ✔' : 'Apply failed');
                        });

                        evt.detail.target.appendChild(clone);
                        return;
                    }
                } catch (e) {
                    console.error(e);
                }
            }
            if (evt.detail.failed && evt.detail.target.id === 'result') {
                evt.detail.target.innerHTML = '<div class="error">' + evt.detail.xhr.responseText + '</div>';
            }
        });
    </script>
</body>
</html>
