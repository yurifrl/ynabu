package ynab

import (
	"strings"

	"github.com/brunomvsouza/ynab.go"
	"github.com/brunomvsouza/ynab.go/api/transaction"
)

// YNABClient wraps the original YNAB client and adds custom functionality
type YNABClient struct {
	client ynab.ClientServicer
}

// TransactionService wraps the original transaction service
type TransactionService struct {
	client *YNABClient
	original *transaction.Service
}

// Transaction wraps the core YNAB transaction adding CustomID extracted from
// the memo first CSV field.
type Transaction struct {
    *transaction.Transaction
    CustomID string
}

// TODO: centralise custom ID generation/usage in one place.
func extractCustomID(tx *transaction.Transaction) string {
    if tx == nil || tx.Memo == nil {
        return ""
    }
    memo := strings.Trim(*tx.Memo, "\"")
    if idx := strings.Index(memo, ","); idx > 0 {
        return memo[:idx]
    }
    return ""
 }

func New(token string) *YNABClient {
	return &YNABClient{
		client: ynab.NewClient(token),
	}
}

func (c *YNABClient) Transaction() *TransactionService {
	return &TransactionService{
		client: c,
		original: c.client.Transaction(),
	}
}

func (ts *TransactionService) GetTransactionsByAccount(budgetID, accountID string, filter interface{}) ([]*Transaction, error) {
	// Call the original client
	var filterPtr *transaction.Filter
	if filter != nil {
		if f, ok := filter.(*transaction.Filter); ok {
			filterPtr = f
		}
	}
	originalTransactions, err := ts.original.GetTransactionsByAccount(budgetID, accountID, filterPtr)
	if err != nil {
		return nil, err
	}

	// Convert to our extended Transaction type with TransactionID
	transactions := make([]*Transaction, 0, len(originalTransactions))
	for _, tx := range originalTransactions {
		customID := extractCustomID(tx)
		if customID == "" {
			// Skip transactions not generated by ynabu (no custom memo)
			continue
		}
		transactions = append(transactions, &Transaction{Transaction: tx, CustomID: customID})
	}

	return transactions, nil
} 